var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page lists all exported functions and types from Pliers.jl. \n\nAll functions are available directly from the main Pliers module. For convenience, related functions are also re-exported through sub-modules that group them by domain.","category":"section"},{"location":"api/#Main-Module","page":"API Reference","title":"Main Module","text":"","category":"section"},{"location":"api/#PMDUtils-Sub-module","page":"API Reference","title":"PMDUtils Sub-module","text":"Re-exports PMD-related utility functions. These functions are also available directly from the main Pliers module.","category":"section"},{"location":"api/#PMDSEUtils-Sub-module","page":"API Reference","title":"PMDSEUtils Sub-module","text":"Re-exports PMDSE-related utility functions. These functions are also available directly from the main Pliers module.","category":"section"},{"location":"api/#PMDGraph-Sub-module","page":"API Reference","title":"PMDGraph Sub-module","text":"Re-exports network visualization and plotting functions. These functions are also available directly from the main Pliers module.","category":"section"},{"location":"api/#Pliers.Pliers","page":"API Reference","title":"Pliers.Pliers","text":"Pliers\n\nA Julia package providing tools for analyzing power distribution systems. Designed to be used in conjunction with PowerModelsDistribution.jl and PowerModelsDistributionStateEstimation.jl for simplified reporting, analysis, and visualization.\n\nSub-modules\n\nThe package provides optional sub-module access for organized imports:\n\nPMDUtils: Re-exports PMD-related utility functions\nPMDSEUtils: Re-exports PMDSE-related utility functions  \nPMDGraph: Re-exports plotting functions\n\nAuthor\n\nMohamed Numair (mnumair.com)\n\n\n\n\n\n","category":"module"},{"location":"api/#Pliers._phase_letter-Tuple{Int64}","page":"API Reference","title":"Pliers._phase_letter","text":"_phase_letter(phase::Int)\n\nConvert a phase index to its corresponding letter designation.\n\nArguments\n\nphase::Int: Phase index (0=ground, 1=a, 2=b, 3=c, 4=neutral).\n\nReturns\n\nA single character string representing the phase.\n\nThrows\n\nErrorException: If phase is not in range 0-4.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers._pretty_diag_matrix-Tuple{Matrix}","page":"API Reference","title":"Pliers._pretty_diag_matrix","text":"_pretty_diag_matrix(mat::Matrix)\n\nPrint a matrix as a pretty table with highlighted diagonal and off-diagonal elements.\n\nArguments\n\nmat::Matrix: The matrix to display.\n\nDescription\n\nDisplays the matrix with row indices prepended and highlights:\n\nDiagonal elements in cyan\nOff-diagonal elements in white\nRow labels in bold\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.add_linecode_sequences!-Tuple{Any}","page":"API Reference","title":"Pliers.add_linecode_sequences!","text":"add_linecode_sequences!(data_eng)\n\nAdd linecode sequences to the data_eng dictionary.\n\nArguments\n\ndata_eng: A dictionary containing network data.\n\nThis function reads linecode data from a file and adds the linecode sequences to the data_eng dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.add_needed_details!-Tuple{Any}","page":"API Reference","title":"Pliers.add_needed_details!","text":"add_needed_details!(data_eng)\n\nAdd additional details to the data_eng dictionary for lines and loads.\n\nArguments\n\ndata_eng: A dictionary containing engineering data.\n\nDescription\n\nThis function adds the following details to the data_eng dictionary for lines:\n\n\"Rs (Ω)\": The resistance of the line calculated as the product of the line length and the resistance per unit length (rs).\n\"Xs (Ω)\": The reactance of the line calculated as the product of the line length and the reactance per unit length (xs).\n\nFor loads, the function adds the following details:\n\n\"PF\": The power factor calculated as the ratio of the active power (pd_nom) to the apparent power (sqrt(pd_nom^2 + qd_nom^2)).\n\"S (VAh)\": The apparent power calculated as the square root of the sum of the squares of the active power and reactive power (sqrt(pd_nom^2 + qd_nom^2)).\n\"connected_phase\": The phase connection of the load, represented as a string (\"a\", \"b\", \"c\", or \"G\") based on the value of the connections field.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.add_vcomplex_vm_va!-Tuple{Any}","page":"API Reference","title":"Pliers.add_vcomplex_vm_va!","text":"add_vcomplex_vm_va!(res)\n\nThis function calculates the complex voltage, magnitude, and angle for each bus in the given network data.\n\nArguments\n\nres: A dictionary containing the network data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.attach_Yg_ground!-Tuple{Any}","page":"API Reference","title":"Pliers.attach_Yg_ground!","text":"attach_Yg_ground!(eng)\n\nThis function attaches the Yg ground to the specified transformer in the given eng structure.\n\nArguments\n\neng: The structure containing the network data.\n\nDescription\n\nThe function sets the base frequency to 50 and the default sbase to 22000.\nFor each transformer in the eng structure, it finds the grounded bus.\nIt then calculates the grnd_react value based on the line data.\nThe function updates the xg and rg values of the grounded bus using the grnd_react value.\nFinally, it deletes the line with the grnd_react value from the eng structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.attach_linecodes!-Tuple{Any}","page":"API Reference","title":"Pliers.attach_linecodes!","text":"attach_linecodes!(data_eng)\n\nAttach linecodes to the given network data.\n\nArguments\n\ndata_eng: A dictionary containing network data.\n\nDescription\n\nThis function attaches linecodes to the lines in the network data. It retrieves the linecode information from the linecode dictionary and assigns the corresponding values to the line dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.attach_loads!-Tuple{Any}","page":"API Reference","title":"Pliers.attach_loads!","text":"attach_loads!(data_eng)\n\nAttach loads to the specified bus in the given data_eng dictionary.\n\nArguments\n\ndata_eng: A dictionary containing network data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.author-Tuple{}","page":"API Reference","title":"Pliers.author","text":"author()\n\nPrint information about the package author.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.convert_keys_to_symbols-Tuple{Any}","page":"API Reference","title":"Pliers.convert_keys_to_symbols","text":"convert_keys_to_symbols(data)\n\nRecursively convert all dictionary keys from strings to symbols.\n\nArguments\n\ndata: Input data structure (Dict, Vector, or other types).\n\nReturns\n\nIf data is a Dict: A new Dict with Symbol keys and recursively converted values.\nIf data is a Vector: A new Vector with recursively converted elements.\nOtherwise: The original value unchanged.\n\nExamples\n\ndata = Dict(\"key1\" => Dict(\"nested\" => 1), \"key2\" => [Dict(\"a\" => 2)])\nresult = convert_keys_to_symbols(data)\n# result[:key1][:nested] == 1\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.diff_vectors-Tuple{Vector{Float64}, Vector{Float64}}","page":"API Reference","title":"Pliers.diff_vectors","text":"diff_vectors(vec1::Vector{Float64}, vec2::Vector{Float64})\n\nPrints the difference between two vectors element-wise.\n\nArguments\n\nvec1::Vector{Float64}: The first vector.\nvec2::Vector{Float64}: The second vector.\n\nExample\n\ndiff_vectors([1.0, 2.0, 3.0], [1.0, 2.0, 4.0])\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.error_text-Tuple{String}","page":"API Reference","title":"Pliers.error_text","text":"error_text(message::String)\n\nPrint an error message with italic red formatting.\n\nArguments\n\nmessage::String: The error message to display.\n\nExamples\n\nerror_text(\"This is an error\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.extra_keys-Tuple{Dict{String, Any}, Any}","page":"API Reference","title":"Pliers.extra_keys","text":"extra_keys(eng_data::Dict{String, Any}, expected_keys)\n\nChecks if there are extra keys in the KeySet of the dictionary eng_data that are not in the list keys and prints them.\n\nArguments\n\neng_data::Dict{String, Any}: A dictionary containing the data to be checked.\nexpected_keys: A list of keys that are expected to be in the dictionary.\nshow_keys=false: A boolean indicating whether to print the expected keys, the keys in the dictionary, and the extra keys.\n\nDescription\n\nThis function compares the keys in the dictionary eng_data with the list of expected_keys and prints a warning message if there are extra keys in the dictionary that are not in the list. If show_keys is set to true, the expected keys, the keys in the dictionary, and the extra keys are printed.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers\neng= PowerModelsDistribution.parse_file(\"example.dss\")\nextra_keys(eng, [\"bus\", \"line\", \"linecode\", \"load\", \"voltage_source\", \"time_series\", \"conductor_ids\", \"name\", \"settings\", \"files\", \"data_model\"])\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.header-Tuple{String}","page":"API Reference","title":"Pliers.header","text":"header(text::String)\n\nPrint a header text with bold, underlined blue formatting.\n\nArguments\n\ntext::String: The text to display as a header.\n\nExamples\n\nheader(\"Section Title\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.isolate_feeder-Tuple{Any, Any}","page":"API Reference","title":"Pliers.isolate_feeder","text":"isolate_feeder(eng, feederno)\n\nGiven a network data structure eng and a feeder number feederno, this function creates a deep copy of the eng structure and isolates the specified feeder.\n\nArguments\n\neng: A network data structure.\nfeederno: The feeder number to isolate.\n\nReturns\n\neng_feeder: A deep copy of the eng structure with the specified feeder isolated.\n\nDescription\n\nThe function isolates the specified feeder by performing the following steps:\n\nCreates a deep copy of the eng structure.\nSets the voltage source bus to the TrLVBus of the specified feeder.\nRetrieves the transformer ID(s) associated with the TrLVBus.\nRetrieves the feeder head bus and the circuit breaker buses of the specified feeder.\nConstructs a list of member lines by traversing the network starting from the feeder head bus.\nFilters out any empty member lines and flattens the list.\nAppends the transformer ID(s), feeder number, and circuit breaker number to the list of member lines.\nRemoves irrelevant data from the eng_feeder structure based on the transformer ID(s), feeder number, and member lines.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.list_files-Tuple{Any}","page":"API Reference","title":"Pliers.list_files","text":"list_files(directory)\n\nList all files recursively in a directory.\n\nArguments\n\ndirectory: Root directory to list files from.\n\nReturns\n\nA vector of full paths to all files in the directory tree.\n\nExamples\n\nall_files = list_files(\"/path/to/dir\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.merge_bus_results!-Tuple{Any, Any}","page":"API Reference","title":"Pliers.merge_bus_results!","text":"merge_bus_results!(res_mn, mn_Feeder_math)\n\nMerge the bus results from res_mn into mn_Feeder_math.\n\nArguments\n\nres_mn: A dictionary containing the bus results.\nmn_Feeder_math: A dictionary representing the network data.\n\nDescription\n\nThis function merges the bus results from res_mn into the mn_Feeder_math dictionary. It updates the \"vi\", \"va\", and \"vcomplex\" values for each bus in the network.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.plot_network-Tuple{Any}","page":"API Reference","title":"Pliers.plot_network","text":"plot_network(eng; plot_bus=true, overlayNetwork=false, save_fig=false, plotname=\"plot.png\"::String, save_json=false, json_filename=\"Networkfile.json\"::String)\n\nThis function plots the network based on the given network data.\n\nArguments\n\neng: A dictionary containing the network data.\nplot_bus: A boolean indicating whether to plot the buses. Default is true.\noverlayNetwork: A boolean indicating whether to overlay the network on an existing plot. Default is false.\nsave_fig: A boolean indicating whether to save the plot as an image file. Default is false.\nplotname: A string specifying the name of the image file to be saved. Default is \"plot.png\".\nsave_json: A boolean indicating whether to save the network data as a JSON file. Default is false.\njson_filename: A string specifying the name of the JSON file to be saved. Default is \"Networkfile.json\".\n\nReturns\n\np: The plot object representing the network plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.polarize-Tuple{Complex}","page":"API Reference","title":"Pliers.polarize","text":"polarize(complex::Complex; scale=1.0, rounding_digits=4)\n\nConvert a complex number to polar notation string format.\n\nArguments\n\ncomplex::Complex: The complex number to convert.\n\nKeyword Arguments\n\nscale::Float64: Scaling factor for the magnitude (default: 1.0).\nrounding_digits::Int: Number of decimal places for rounding (default: 4).\n\nReturns\n\nA string in the format \"magnitude ∠ angle_degrees\".\n\nExamples\n\npolarize(1 + 1im)  # \"1.4142 ∠ 45.0\"\npolarize(1 + 1im; scale=1000)  # \"1414.2136 ∠ 45.0\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.read_data-Tuple{String}","page":"API Reference","title":"Pliers.read_data","text":"read_data(path::String)\n\nReads and deserializes data from the specified path.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.rm_spanish_transformer!-Tuple{Any}","page":"API Reference","title":"Pliers.rm_spanish_transformer!","text":"rm_spanish_transformer!(data_eng)\n\nRemove the Spanish transformer from the given data_eng dictionary.\n\nArguments\n\ndata_eng: A dictionary containing the network data.\n\nDescription\n\nThis function removes the Spanish transformer from the data_eng dictionary. It updates the voltage source parameters, deletes the transformer, deletes the lines connected before the transformer, updates the bus settings, and resets the terminals and grounded status of the buses.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.save_data-Tuple{Any, String}","page":"API Reference","title":"Pliers.save_data","text":"save_data(data, path::String)\n\nSerializes and saves data to the specified path.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.search_directories-Tuple{Any, Any}","page":"API Reference","title":"Pliers.search_directories","text":"search_directories(directory, directory_name)\n\nSearch recursively for directories containing a specific string in their name.\n\nArguments\n\ndirectory: Root directory to start the search.\ndirectory_name: String to search for in directory names.\n\nReturns\n\nA vector of full paths to matching directories.\n\nExamples\n\ndirs = search_directories(\"/path/to/dir\", \"test\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.search_files-Tuple{Any, Any}","page":"API Reference","title":"Pliers.search_files","text":"search_files(directory, file_name)\n\nSearch recursively for files containing a specific string in their name.\n\nArguments\n\ndirectory: Root directory to start the search.\nfile_name: String to search for in file names.\n\nReturns\n\nA vector of full paths to matching files.\n\nExamples\n\nfiles = search_files(\"/path/to/dir\", \"test\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.set_journal_theme-Tuple{}","page":"API Reference","title":"Pliers.set_journal_theme","text":"set_journal_theme(; fontsize=nothing)\n\nSet a Makie theme suitable for journal publications (IEEE style).\n\nThis function configures a Makie theme with appropriate fonts, colors, and styling for publication-quality figures. The theme uses TeX Gyre Termes fonts when available, falling back to Computer Modern if not found.\n\nKeyword Arguments\n\nfontsize: Optional font size override. Defaults to 8pt if not specified.\n\nReturns\n\nA tuple containing unit conversion factors:\n\ninch::Float64: Pixels per inch (96)\npt::Float64: Pixels per point (4/3)\ncm::Float64: Pixels per centimeter\nieeecolumn::Float64: Width of a single IEEE column in pixels (3.5 inches)\nieee2column::Float64: Width of a double IEEE column in pixels (7.16 inches)\n\nExamples\n\ninch, pt, cm, ieeecolumn, ieee2column = set_journal_theme()\nfig = Figure(size=(ieeecolumn, ieeecolumn))\n\nNotes\n\nIEEE Figure Sizes:\n\nOne column width: 3.5 inches, 88.9 mm, or 21 picas\nTwo columns width: 7.16 inches, 182 mm, or 43 picas\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.show_example-Tuple{Dict}","page":"API Reference","title":"Pliers.show_example","text":"show_example(dict::Dict)\n\nReturn the value of the first entry in a dictionary.\n\nArguments\n\ndict::Dict: A dictionary to inspect.\n\nReturns\n\nThe value associated with the first key in the dictionary.\n\nExamples\n\nd = Dict(\"a\" => 1, \"b\" => 2)\nshow_example(d)  # Returns 1 or 2 depending on iteration order\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.sub_header-Tuple{String}","page":"API Reference","title":"Pliers.sub_header","text":"sub_header(text::String)\n\nPrint a sub-header text with bold, italic blue formatting.\n\nArguments\n\ntext::String: The text to display as a sub-header.\n\nExamples\n\nsub_header(\"Sub-section Title\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.sub_sub_header-Tuple{String}","page":"API Reference","title":"Pliers.sub_sub_header","text":"sub_sub_header(text::String)\n\nPrint a sub-sub-header text with bold magenta formatting.\n\nArguments\n\ntext::String: The text to display as a sub-sub-header.\n\nExamples\n\nsub_sub_header(\"Minor Section Title\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.warning_text-Tuple{String}","page":"API Reference","title":"Pliers.warning_text","text":"warning_text(message::String)\n\nPrint a warning message with italic yellow formatting.\n\nArguments\n\nmessage::String: The warning message to display.\n\nExamples\n\nwarning_text(\"This is a warning\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils","page":"API Reference","title":"Pliers.PMDUtils","text":"PMDUtils\n\nInternal sub-module providing utility functions for PowerModelsDistribution (PMD) workflows.\n\nThis module re-exports functions from the main Pliers module for:\n\nProcessing power flow solutions (voltage fluffing, dictification)\nImpedance calculations (Kron reduction, sequence components)\nNetwork data manipulation\nResult analysis and transformation\nEngineering and mathematical model exploration\n\nSee the main Pliers module for function documentation.\n\n\n\n\n\n","category":"module"},{"location":"api/#Pliers.PMDUtils._separate_phase_neutral_voltages-Tuple{Any, Any}","page":"API Reference","title":"Pliers.PMDUtils._separate_phase_neutral_voltages","text":"_separate_phase_neutral_voltages(pf_sol, bus_index)\n\nSeparate the phase and neutral voltages from the power flow solution for a given bus.\n\nArguments\n\npf_sol::Dict: The power flow solution dictionary containing voltage information.\nbus_index::Int: The index of the bus for which to separate the voltages.\n\nReturns\n\nphase_voltage::Vector{ComplexF64}: A vector containing the phase voltages (up to 3 phases).\nneutral_voltage::ComplexF64: The neutral voltage. If the neutral voltage is not present, returns 0 + 0im \"assuming grounded\".\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.add_vmn_p_q-Tuple{Any, Any}","page":"API Reference","title":"Pliers.PMDUtils.add_vmn_p_q","text":"add_vmn_p_q(math, pf_sol) -> math_meas\n\nAdds voltage magnitude (VMN), active power (P), and reactive power (Q) measurements  to the given mathematical model.\n\nArguments\n\nmath: The mathematical model to which the measurements will be added.\npf_sol: The power flow solution containing the necessary data for VMN, P, and Q.\n\nReturns\n\nmath_meas: A deep copy of the input math with the added VMN, P, and Q measurements.\n\nNotes\n\nThis function internally calls _get_vmn to add voltage magnitude measurements  and _get_pd_qd to add active and reactive power measurements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.bus_phasor!-Tuple{Makie.PolarAxis, Dict{String, Any}, Integer}","page":"API Reference","title":"Pliers.PMDUtils.bus_phasor!","text":"bus_phasor!(ax::PolarAxis, eng::Dict{String, Any}, bus_id::String;\n            linestyle=:solid, colors=[:darkred, :darkgreen, :darkblue, :black])\n\nPlots voltage phasors for a given bus onto an existing PolarAxis.\n\nArguments\n\nax::PolarAxis: The Makie PolarAxis to plot on.\neng::Dict{String, Any}: The engineering data dictionary containing results.\nbus_id::String: The ID of the bus to plot phasors for.\nlinestyle: The line style for the phasors (default: :solid).\ncolors: The colors to use for the different phases (default: [:darkred, :darkgreen, :darkblue, :black]).\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.bus_phasor-Tuple{Dict{String, Any}, Integer}","page":"API Reference","title":"Pliers.PMDUtils.bus_phasor","text":"bus_phasor(eng::Dict{String, Any}, bus_id::String;\n           makie_backend=WGLMakie, fig_size=(800, 800))\n\nCreates a new figure and plots voltage phasors for a given bus.\n\nArguments\n\neng::Dict{String, Any}: The engineering data dictionary containing results.\nbus_id::String: The ID of the bus to plot phasors for.\nmakie_backend: The Makie backend to activate (default: WGLMakie).\nfig_size: The size of the figure (default: (800, 800)).\n\nReturns\n\nFigure: The Makie figure containing the phasor plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.buses_table-Tuple{Dict{String, Any}, Function}","page":"API Reference","title":"Pliers.PMDUtils.buses_table","text":"buses_table(eng::Dict{String,Any}, condition)\n\nGenerate and display a filtered table of buses from the given engineering data.\n\nArguments\n\neng::Dict{String,Any}: A dictionary containing engineering data, which must include a \"bus\" key with bus information.\ncondition: A function that takes a bus dictionary as input and returns a boolean indicating whether the bus meets the filtering criteria.\n\nDescription\n\nThis function extracts bus information from the provided engineering data dictionary, applies the given condition to filter the buses, and then displays the filtered buses in a formatted table. Each bus is augmented with its bus_id before filtering. The table includes columns for bus_id, status, terminals, rg, xg, and grounded.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers \neng= Pliers.parse_file(\"example.dss\")\nbuses_table(eng, bus -> bus[\"bus_id\"] ==\"sourcebus\")\n\n````\nor \n\n\njulia buses_table(eng, bus -> haskey(bus, \"grounded\") && bus[\"grounded\"]==[4]) ```\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.buses_table-Tuple{Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDUtils.buses_table","text":"buses_table(eng::Dict{String, Any})\n\nGenerate a table summarizing the buses in the electrical network described by the dictionary eng.\n\nArguments\n\neng::Dict{String, Any}: A dictionary containing various components of the electrical network.\n\nDescription\n\nThis function extracts the buses from the eng dictionary and creates a DataFrame with the bus ID, status, terminals, resistance to ground (rg), reactance to ground (xg), and grounding status. It then prints a formatted table of the buses.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers \neng= PowerModelsDistribution.parse_file(\"example.dss\")\nbuses_table(eng)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.buses_table-Tuple{String}","page":"API Reference","title":"Pliers.PMDUtils.buses_table","text":"Processes a DSS file and calls the function with the parsed data.\n\nArguments\n\ndss::String: The path to the DSS file to be processed.\n\nReturns\n\nWhatever function returns when called with parsed data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.calc_bases_from_dict-Tuple{Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDUtils.calc_bases_from_dict","text":"calcbasesfromdict(data::Dict{String,Any}; returndict=false) \n\nCalculate electrical base quantities from a data dictionary.\n\nArguments\n\ndata::Dict{String,Any}: A dictionary containing network data. It must include:\n\"per_unit\": (optional) A boolean indicating whether the values are in per-unit.\n\"settings\": A nested dictionary with the following keys:\n\"vbases_default\": A collection where the first element has a second field representing the base voltage in volts.\n\"voltage_scale_factor\": A scaling factor for voltage.\n\"sbase_default\": The default base apparent power in VA.\n\"power_scale_factor\": A scaling factor for power.\nreturn_dict::Bool=false: If true, returns a dictionary of base quantities; otherwise, returns a tuple.\n\nReturns\n\nIf return_dict == false, returns a tuple:\n\nis_perunit::Bool: Indicates if the values are in per-unit.\nvbase_V::Float64: The base voltage in volts (phase-to-neutral).\nsbase_VA::Float64: The base apparent power in volt-amperes.\nZbase_Ω::Float64: The base impedance in ohms.\nIbase_A::Float64: The base current in amperes (phase current).\nvbase_ll::Float64: The base line-to-line voltage in volts.\nIbase_A_ll::Float64: The base line current in amperes.\nIbase_A_ϕ::Float64: The base phase current in amperes.\n\nIf return_dict == true, returns a Dict{String,Any} with the following keys:\n\n\"is_perunit\"\n\"vbase_V\"\n\"sbase_VA\"\n\"Zbase_Ω\"\n\"Ibase_A\"\n\"vbase_ll\"\n\"Ibase_A_ll\"\n\"Ibase_A_ϕ\"\n\nExample\n\nisperunit, vbaseV, sbaseVA, ZbaseΩ, IbaseA, vbasell, IbaseAll, IbaseAϕ = calcbasesfrom_dict(data)\nbases = calcbasesfromdict(data; returndict=true)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.calculate_vuf!-Tuple{Any, Any}","page":"API Reference","title":"Pliers.PMDUtils.calculate_vuf!","text":"calculate_vuf(PF_RES, math)\n\nCalculates the Voltage Unbalance Factor (VUF) for each bus in the power flow result.\n\nVUF is defined as:     VUF = |V₋ / V₊| × 100% where:\n\nV₊ is the positive-sequence voltage\nV₋ is the negative-sequence voltage\n\nIt uses the phase-to-neutral complex voltages from the power flow solution, assumed to be available at each bus under keys \"1\", \"2\", \"3\" (phases) and \"4\" (neutral) after applying dictify_solution!.\n\nReturns the modified PFRES with VUF values added at each bus as:     PFRES[\"solution\"][\"bus\"][bus_id][\"vuf\"] = <Float64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.dictify_solution!-Tuple{Dict{String, Any}, Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDUtils.dictify_solution!","text":"dictify_solution!(pf_sol::Dict{String, Any}, math::Dict{String, Any}; formulation = \"IVR\")\n\nTransforms and organizes the solution data from a power flow computation into a structured dictionary format.\n\nArguments\n\npf_sol::Dict{String, Any}: A dictionary containing the power flow solution data.\nmath::Dict{String, Any}: A dictionary containing the mathematical model data.\nformulation::String (optional): Specifies the formulation type to be used. Defaults to \"IVR\".\n\nDescription\n\nThis function modifies the pf_sol dictionary in-place by calling helper functions to process and structure data for buses, loads, branches, and generators. Each helper function is responsible for handling a specific component of the power flow solution.\n\nNotes\n\nThe function assumes that the helper functions solution_dictify_buses!, solution_dictify_loads!, solution_dictify_branches!, and solution_dictify_gens! are defined and properly handle their respective components.\nThe formulation parameter allows customization of the solution processing based on the formulation type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.eng_report-Tuple{Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDUtils.eng_report","text":"eng_report(eng::Dict{String, Any})\n\nGenerate a report for the electrical network described by the dictionary eng.\n\nArguments\n\neng::Dict{String, Any}: A dictionary containing various components of the electrical network.\n\nDescription\n\nThis function extracts various components from the eng dictionary, such as buses, lines, linecodes, loads, voltage sources, time series data, conductor IDs, name, settings, files, and data model. It then prints a formatted report summarizing the contents of the network, including the number of each component present.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers \neng= PowerModelsDistribution.parse_file(\"example.dss\")\neng_report(eng)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.fluff_bus_voltages!-Tuple{Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDUtils.fluff_bus_voltages!","text":"fluff_bus_voltages(PF_Res::Dict{String, Any})\n\nThis function is used to get all possible voltage forms from the output of the OPF voltage variables, so it processes the bus voltages in the given Power Flow Results dictionary PF_Res. For each bus in PF_Res[\"bus\"], it checks if the bus has real (vr) and imaginary (vi) voltage components. If both components are present, it calculates the complex voltage V, the voltage magnitude vm, and the voltage angle va for the bus. A warning is issued indicating that only vr and vi can be processed.\n\nArguments\n\nPF_Res::Dict{String, Any}: A dictionary containing the Power Flow Results solution, including bus voltage information.\n\n!!! You need to pass the [\"solution\"] key of the Power Flow Results dictionary.\n\nModifies\n\nAdds the following keys to each bus dictionary if vr and vi are present:\nV: The complex voltage calculated as vr + vi*im.\nvm: The magnitude of the complex voltage.\nva: The angle of the complex voltage.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.get_sequence_components-Tuple{Matrix}","page":"API Reference","title":"Pliers.PMDUtils.get_sequence_components","text":"get_sequence_components(m_phase::Matrix{ComplexF64})\n\nCalculates the zero, positive, and negative sequence components of a 3x3 complex matrix representing phase quantities (e.g., impedance or admittance).\n\nArguments\n\nm_phase::Matrix{ComplexF64}: The input 3x3 complex matrix in phase coordinates.\n\nReturns\n\nTuple{Matrix{ComplexF64}, ComplexF64, ComplexF64, ComplexF64}: A tuple containing:\nThe full 3x3 sequence matrix (M_seq).\nThe zero sequence component (diagonal element M_seq[1, 1]).\nThe positive sequence component (diagonal element M_seq[2, 2]).\nThe negative sequence component (diagonal element M_seq[3, 3]).\n\nThrows\n\nDimensionMismatch: If the input matrix is not 3x3.\n\nUsage\n\nAssume 'Mred' is the 3x3 matrix obtained from the previous Kron reduction step Let's create a sample symmetrical 3x3 matrix for demonstration: Zphase = ComplexF64[     10+5im   2+1im   2+1im;     2+1im   10+5im  2+1im;     2+1im   2+1im   10+5im ] This represents a balanced system where off-diagonals are equal.\n\nOr use a more general (unbalanced) example: Z_phase = ComplexF64[      10+5im   1+0.5im  2+1im;      1+0.5im  12+6im   3+1.5im;      2+1im    3+1.5im  11+5.5im ]\n\ntry     # Calculate sequence components     Zseqmatrix, Z0, Z1, Z2 = calculatesequencecomponents(Z_phase)\n\nprintln(\"Original Phase Matrix Z_phase:\")\ndisplay(Z_phase)\n\nprintln(\"\n\nSequence Matrix Zseq:\")     display(round.(Zseq_matrix; digits=4)) # Round for cleaner display\n\nprintln(\"\n\nSequence Components:\")     println(\"Zero Sequence (Z0): \", round(Z0; digits=4))     println(\"Positive Sequence (Z1): \", round(Z1; digits=4))     println(\"Negative Sequence (Z2): \", round(Z2; digits=4))\n\ncatch e     println(\"Error: \", e) end\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.linecodes_table-Tuple{String}","page":"API Reference","title":"Pliers.PMDUtils.linecodes_table","text":"Processes a DSS file and calls the function with the parsed data.\n\nArguments\n\ndss::String: The path to the DSS file to be processed.\n\nReturns\n\nWhatever function returns when called with parsed data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.lines_table-Tuple{Dict{String, Any}, Function}","page":"API Reference","title":"Pliers.PMDUtils.lines_table","text":"lines_table(eng::Dict{String,Any}, condition)\n\nGenerate and display a filtered table of lines from the given engineering data.\n\nArguments\n\neng::Dict{String,Any}: A dictionary containing engineering data, which must include a \"line\" key with line information.\ncondition: A function that takes a line dictionary as input and returns a boolean indicating whether the line meets the filtering criteria.\n\nDescription\n\nThis function extracts line information from the provided engineering data dictionary, applies the given condition to filter the lines, and then displays the filtered lines in a formatted table. Each line is augmented with its line_id before filtering. The table includes columns for line_id, source_id, f_bus, f_connections, t_bus, t_connections, length, linecode, and status.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers\neng= PowerModelsDistribution.parse_file(\"example.dss\")\nlines_table(eng, line -> line[\"length\"] > 0.75)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.lines_table-Tuple{Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDUtils.lines_table","text":"lines_table(eng::Dict{String, Any})\n\nGenerate a table summarizing the lines in the electrical network described by the dictionary eng.\n\nArguments\n\neng::Dict{String, Any}: A dictionary containing various components of the electrical network.\n\nDescription\n\nThis function extracts the lines from the eng dictionary and creates a DataFrame with the line ID, status, from bus, to bus, length, resistance, reactance, and linecode. It then prints a formatted table of the lines.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers\neng= PowerModelsDistribution.parse_file(\"example.dss\")\nlines_table(eng)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.lines_table-Tuple{String}","page":"API Reference","title":"Pliers.PMDUtils.lines_table","text":"Processes a DSS file and calls the function with the parsed data.\n\nArguments\n\ndss::String: The path to the DSS file to be processed.\n\nReturns\n\nWhatever function returns when called with parsed data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.loads_table-Tuple{Dict{String, Any}, Function}","page":"API Reference","title":"Pliers.PMDUtils.loads_table","text":"loads_table(eng::Dict{String,Any}, condition)\n\nGenerate and display a filtered table of loads from the given engineering data.\n\nArguments\n\neng::Dict{String,Any}: A dictionary containing engineering data, which must include a \"load\" key with load information.\ncondition: A function that takes a load dictionary as input and returns a boolean indicating whether the load meets the filtering criteria.\n\nDescription\n\nThis function extracts load information from the provided engineering data dictionary, applies the given condition to filter the loads, and then displays the filtered loads in a formatted table. Each load is augmented with its load_id before filtering. The table includes columns for load_id, source_id, bus, connections, vm_nom, pd_nom, qd_nom, configuration, model, dispatchable, and status.\n\nExample\n\nfilter the loads by the value of pd_nom:   julia   loads_table(eng, load -> load[\"pd_nom\"] > [0.33])\nfilter the loads by the phase connectivity   julia   loads_table(eng, load -> load[\"connections\"] == [1, 4])\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.loads_table-Tuple{Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDUtils.loads_table","text":"loads_table(eng::Dict{String, Any})\n\nGenerate a table summarizing the loads in the electrical network described by the dictionary eng.\n\nArguments\n\neng::Dict{String, Any}: A dictionary containing various components of the electrical network.\n\nDescription\n\nThis function extracts the loads from the eng dictionary and creates a DataFrame with the load ID, status, bus, phases, kw, kvar, and kva. It then prints a formatted table of the loads.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers\neng= PowerModelsDistribution.parse_file(\"example.dss\")\nloads_table(eng)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.loads_table-Tuple{String}","page":"API Reference","title":"Pliers.PMDUtils.loads_table","text":"Processes a DSS file and calls the function with the parsed data.\n\nArguments\n\ndss::String: The path to the DSS file to be processed.\n\nReturns\n\nWhatever function returns when called with parsed data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.math_transformers_table-Tuple{Dict{String, Any}, Function}","page":"API Reference","title":"Pliers.PMDUtils.math_transformers_table","text":"math_transformers_table(math::Dict{String, Any}, condition::Function)\n\nGenerate and display a filtered table of transformers from the given mathematical model data.\n\nArguments\n\nmath::Dict{String,Any}: A dictionary containing mathematical model data, which must include a \"transformer\" key with transformer information.\ncondition: A function that takes a transformer dictionary as input and returns a boolean indicating whether the transformer meets the filtering criteria.\n\nDescription\n\nThis function extracts transformer information from the provided mathematical model dictionary, applies the given condition to filter the transformers, and then displays the filtered transformers in a formatted table.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers\neng = PowerModelsDistribution.parse_file(\"example.dss\")\nmath = PowerModelsDistribution.transform_data_model(eng)\nmath_transformers_table(math, transformer -> transformer[\"f_bus\"] == 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.math_transformers_table-Tuple{Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDUtils.math_transformers_table","text":"math_transformers_table(math::Dict{String, Any})\n\nGenerate a table summarizing the transformers in the mathematical model described by the dictionary math.\n\nArguments\n\nmath::Dict{String, Any}: A dictionary containing various components of the mathematical model.\n\nDescription\n\nThis function extracts the transformers from the math dictionary and creates a DataFrame with the transformer index, name, source ID, from/to buses, connections, configuration, tap settings, voltage bases, polarity, power/current limits, and status. It then prints a formatted table of the transformers.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers \neng = PowerModelsDistribution.parse_file(\"example.dss\")\nmath = PowerModelsDistribution.transform_data_model(eng)\nmath_transformers_table(math)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.remove_virtual_bus!-Tuple{Any}","page":"API Reference","title":"Pliers.PMDUtils.remove_virtual_bus!","text":"remove_virtual_bus!(math_b)\n\nRemove virtual bus, branch, and generator from the given math dictionary.\n\nArguments\n\nmath_b::Dict: A dictionary containing information about buses, branches, and generators.\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.show_transformer_math_components-Tuple{Any}","page":"API Reference","title":"Pliers.PMDUtils.show_transformer_math_components","text":"show_transformer_math_components(math; suppress_print::Bool=false)\n\nExtract and display transformer mathematical components from a power system model.\n\nArguments\n\nmath::Dict: A dictionary containing the mathematical model representation with  \"map\" and element type keys (e.g., \"bus\", \"branch\", \"transformer\")\nsuppress_print::Bool=false: If true, suppresses console output and only returns results\n\nReturns\n\nDict{String, Any}: A nested dictionary organized by transformer name, containing:\n\"buses\": Dictionary of bus elements mapped to this transformer\n\"branches\": Dictionary of branch elements mapped to this transformer\n\"transformers\": Dictionary of transformer elements mapped to this transformer\n\nDescription\n\nThis function identifies all transformers in the mathematical model that were converted  from engineering model representation and extracts the associated mathematical components  (buses, branches, transformers). Each transformer is identified by the presence of an  \"unmapfunction\" equal to \"mapmath2engtransformer!\" in the mapping structure.\n\nIf suppress_print=false, displays formatted console output showing the transformation  process and component details.\n\nExample\n\nmappedtransformers = showtransformermathcomponents(math, suppress_print=false)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.transformers_table-Tuple{Dict{String, Any}, Function}","page":"API Reference","title":"Pliers.PMDUtils.transformers_table","text":"transformers_table(eng::Dict{String,Any}, condition)\n\nGenerate and display a filtered table of transformers from the given engineering data.\n\nArguments\n\neng::Dict{String,Any}: A dictionary containing engineering data, which must include a \"transformer\" key with transformer information.\ncondition: A function that takes a transformer dictionary as input and returns a boolean indicating whether the transformer meets the filtering criteria.\n\nDescription\n\nThis function extracts transformer information from the provided engineering data dictionary, applies the given condition to filter the transformers, and then displays the filtered transformers in a formatted table. Each transformer is augmented with its transformer_id before filtering.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers\neng= PowerModelsDistribution.parse_file(\"example.dss\")\ntransformers_table(eng, transformer -> transformer[\"vm_nom\"][1] > 10.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.transformers_table-Tuple{Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDUtils.transformers_table","text":"transformers_table(eng::Dict{String, Any})\n\nGenerate a table summarizing the transformers in the electrical network described by the dictionary eng.\n\nArguments\n\neng::Dict{String, Any}: A dictionary containing various components of the electrical network.\n\nDescription\n\nThis function extracts the transformers from the eng dictionary and creates a DataFrame with the transformer ID, name, source ID, buses, connections, nominal voltage (vmnom), nominal power (smnom), configuration, short-circuit reactance (xsc), winding resistance (rw), no-load loss, magnetizing current (cmag), tap settings (tmset), fixed taps (tmfix), polarity, and status. It then prints a formatted table of the transformers.\n\nExample\n\nusing PowerModelsDistribution\nusing Pliers \neng= PowerModelsDistribution.parse_file(\"example.dss\")\ntransformers_table(eng)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDUtils.transformers_table-Tuple{String}","page":"API Reference","title":"Pliers.PMDUtils.transformers_table","text":"Processes a DSS file and calls the function with the parsed data.\n\nArguments\n\ndss::String: The path to the DSS file to be processed.\n\nReturns\n\nWhatever function returns when called with parsed data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDSEUtils","page":"API Reference","title":"Pliers.PMDSEUtils","text":"PMDSEUtils\n\nInternal sub-module providing utility functions for PowerModelsDistributionStateEstimation (PMDSE) workflows.\n\nThis module re-exports functions from the main Pliers module for:\n\nState estimation result visualization\nMeasurement residual analysis\nMeasurement data processing and writing\n\nSee the main Pliers module for function documentation.\n\n\n\n\n\n","category":"module"},{"location":"api/#Pliers.PMDSEUtils._calculate_MAPE-Tuple{Any, Any, Any}","page":"API Reference","title":"Pliers.PMDSEUtils._calculate_MAPE","text":"_calculate_MAPE(SE_RES, PF_RES, math)\n\nCalculate the Mean Absolute Percentage Error (MAPE) between state estimation (SE) results  and power flow (PF) results.\n\nArguments\n\nSE_RES::Dict: A dictionary containing the state estimation results.\nPF_RES::Dict: A dictionary containing the power flow results.\nmath: A mathematical utility or context used for processing the solutions.\n\nReturns\n\nmean_APE::Float64: The mean absolute percentage error across all buses and terminals.\nAPEs::Vector{Float64}: A vector containing the absolute percentage errors for each bus and terminal.\n\nDetails\n\nThe function compares the voltage solutions from the state estimation (SE_RES) and  power flow (PF_RES) results. It calculates the absolute percentage error (APE) for  each bus and terminal, filters out any NaN values, and computes the mean APE.\n\nNotes\n\nThe function assumes that the solutions in SE_RES and PF_RES are structured as  dictionaries with nested keys for buses and their respective voltages.\nThe dictify_solution! function is used to process the solutions before comparison.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph","page":"API Reference","title":"Pliers.PMDGraph","text":"PMDGraph\n\nInternal sub-module providing plotting functions for power distribution network visualization.\n\nThis module re-exports functions from the main Pliers module for:\n\nNetwork tree visualization\nCoordinate-based network plotting\nGeographic map overlays\nBus phasor diagram plotting\n\nSee the main Pliers module for function documentation.\n\n\n\n\n\n","category":"module"},{"location":"api/#Pliers.PMDGraph.create_network_graph-Tuple{Dict{String, Any}, Any}","page":"API Reference","title":"Pliers.PMDGraph.create_network_graph","text":"create_network_graph(data::Dict{String,Any}, fallback_layout)\n\nCreate a MetaDiGraph representation of a power distribution network.\n\nAutomatically detects whether the input data is in ENGINEERING or MATHEMATICAL format and calls the appropriate graph creation function.\n\nArguments\n\ndata::Dict{String,Any}: Network data dictionary (either ENGINEERING or MATHEMATICAL model).\nfallback_layout: Layout function to use if no coordinates are available.\n\nReturns\n\nThe result of either create_network_graph_eng or create_network_graph_math depending on the data model type.\n\nSee also\n\ncreate_network_graph_eng\ncreate_network_graph_math\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.create_network_graph_eng-Tuple{Dict{String, Any}, Any}","page":"API Reference","title":"Pliers.PMDGraph.create_network_graph_eng","text":"create_network_graph_eng(eng::Dict{String,Any}, fallback_layout) -> MetaDiGraph, Function, Dict{Symbol,Any}\n\nCreate a MetaDiGraph from an ENGINEERING model network.\n\nConstructs a directed graph where vertices represent buses and edges represent lines and transformers. Bus properties are enriched with connected loads, shunts, and voltage sources.\n\nArguments\n\neng::Dict{String,Any}: Network data in ENGINEERING format.\nfallback_layout: Layout function to use if bus coordinates are not available.\n\nReturns\n\nA tuple containing:\n\nnetwork_graph::MetaDiGraph: The constructed network graph.\nGraphLayout::Function: Layout function for plotting (coordinate-based or fallback).\neng_sym::Dict{Symbol,Any}: Copy of input data with keys converted to symbols.\n\nExamples\n\nnetwork_graph, layout, eng_sym = create_network_graph_eng(eng, GraphMakie.Buchheim())\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.create_network_graph_math-Tuple{Dict{String, Any}, Any}","page":"API Reference","title":"Pliers.PMDGraph.create_network_graph_math","text":"create_network_graph_math(math::Dict{String,Any}, fallback_layout) -> MetaDiGraph, Function, Dict{Symbol,Any}\n\nCreate a MetaDiGraph from a MATHEMATICAL model network.\n\nConstructs a directed graph where vertices represent buses and edges represent branches. Bus properties are enriched with connected loads, shunts, and generators.\n\nArguments\n\nmath::Dict{String,Any}: Network data in MATHEMATICAL format.\nfallback_layout: Layout function to use if bus coordinates are not available.\n\nReturns\n\nA tuple containing:\n\nnetwork_graph::MetaDiGraph: The constructed network graph.\nGraphLayout::Function: Layout function for plotting (coordinate-based or fallback).\nmath_sym::Dict{Symbol,Any}: Copy of input data with keys converted to symbols.\n\nExamples\n\nnetwork_graph, layout, math_sym = create_network_graph_math(math, GraphMakie.Buchheim())\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.default_index_value-Tuple{Integer, Symbol, Set}","page":"API Reference","title":"Pliers.PMDGraph.default_index_value","text":"default_index_value(v, prop, index_values; exclude=nothing)\n\nProvides a default index value for a vertex if no value currently exists. The default is a string: \"propi\" where prop is the property name and i is the vertex number. If some other vertex already has this name, a randomized string is generated (though the way it is generated is deterministic).\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.get_graph_edge-Tuple{Any, Any}","page":"API Reference","title":"Pliers.PMDGraph.get_graph_edge","text":"get_graph_edge(G, edge_id)\nget_graph_edge(G, edge_id, key)\n\nGet properties of an edge (line/branch) from the network graph.\n\nArguments\n\nG::MetaDiGraph: The network graph.\nedge_id: Edge identifier (line ID for ENGINEERING, branch ID for MATHEMATICAL).\nkey: (Optional) Specific property key to retrieve.\n\nReturns\n\nWithout key: Dictionary of all edge properties.\nWith key: Value of the specified property.\n\nExamples\n\nprops = get_graph_edge(G, \"line1\")\nimpedance = get_graph_edge(G, \"line1\", \"rs\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.get_graph_node-Tuple{Any, Any}","page":"API Reference","title":"Pliers.PMDGraph.get_graph_node","text":"get_graph_node(G, node)\nget_graph_node(G, node, key)\n\nGet properties of a node (bus) from the network graph.\n\nArguments\n\nG::MetaDiGraph: The network graph.\nnode: Node identifier (bus ID).\nkey: (Optional) Specific property key to retrieve.\n\nReturns\n\nWithout key: Dictionary of all node properties.\nWith key: Value of the specified property.\n\nExamples\n\nprops = get_graph_node(G, \"bus1\")\nvoltage = get_graph_node(G, \"bus1\", \"vm\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.network_graph_map_plot-Tuple{MetaGraphs.MetaDiGraph, Function}","page":"API Reference","title":"Pliers.PMDGraph.network_graph_map_plot","text":"network_graph_map_plot(\n    network_graph::MetaDiGraph,\n    GraphLayout::Function;\n    tiles_provider=TileProviders.Google(:satelite),\n    zoom_lon=0.0942,\n    zoom_lat=0.0942,\n    makie_backend=WGLMakie,\n    figure_size=(1000, 1200),\n    nlabels=nothing,\n    ilabels=nothing,\n    node_color=:black,\n    node_size=automatic,\n    node_marker=automatic,\n    node_strokewidth=automatic,\n    show_node_labels=false,\n    elabels=nothing,\n    show_edge_labels=false,\n    edge_color=:black,\n    elabels_color=:black,\n    elabels_fontsize=10,\n    tangents=((0,-1),(0,-1)),\n    arrow_show=false,\n    arrow_marker='➤',\n    arrow_size=12,\n    arrow_shift=0.5,\n    kwargs...\n)\n\nPlots a network graph on a map using the specified layout and visual properties.\n\nArguments\n\nnetwork_graph::MetaDiGraph: The network graph to be plotted.\nGraphLayout::Function: The layout function for positioning the nodes.\ntiles_provider: The tile provider for the map background. Default is TileProviders.Google(:satelite).\nzoom_lon: The longitudinal zoom level. Default is 0.0942.\nzoom_lat: The latitudinal zoom level. Default is 0.0942.\nmakie_backend: The Makie backend to use for plotting. Default is WGLMakie.\nfigure_size: The size of the figure in pixels. Default is (1000, 1200).\nnlabels: Node labels. Default is nothing.\nilabels: Internal labels. Default is nothing.\nnode_color: Color of the nodes. Default is :black.\nnode_size: Size of the nodes. Default is automatic.\nnode_marker: Marker style for the nodes. Default is automatic.\nnode_strokewidth: Stroke width of the nodes. Default is automatic.\nshow_node_labels: Whether to show node labels. Default is false.\nelabels: Edge labels. Default is nothing.\nshow_edge_labels: Whether to show edge labels. Default is false.\nedge_color: Color of the edges. Default is :black.\nelabels_color: Color of the edge labels. Default is :black.\nelabels_fontsize: Font size of the edge labels. Default is 10.\ntangents: Tangents for the edges. Default is ((0,-1),(0,-1)).\narrow_show: Whether to show arrows on the edges. Default is false.\narrow_marker: Marker style for the arrows. Default is '➤'.\narrow_size: Size of the arrows. Default is 12.\narrow_shift: Shift of the arrows. Default is 0.5.\nkwargs: Additional keyword arguments.\n\nReturns\n\nA map object with the plotted network graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.network_graph_plot-Tuple{MetaGraphs.MetaDiGraph}","page":"API Reference","title":"Pliers.PMDGraph.network_graph_plot","text":"network_graph_plot(network_graph::MetaDiGraph; layout=GraphMakie.Buchheim(), figure_size=(1000, 1200), node_color=:black, node_size=automatic, node_marker=automatic, node_strokewidth=automatic, show_node_labels=false, show_edge_labels=false, edge_color=:black, elabels_color=:black, elabels_fontsize=10, tangents=((0,-1),(0,-1)), arrow_show=false, arrow_marker='➤', arrow_size=50, arrow_shift=0.5)\n\nPlots the given network graph using the specified layout and styling options.\n\nArguments\n\nnetwork_graph::MetaDiGraph: The network graph to be plotted.\n\nKeyword Arguments\n\nlayout: The layout algorithm to use for positioning the nodes (default: GraphMakie.Buchheim()).\nfigure_size: The size of the figure in pixels (default: (1000, 1200)).\nnode_color: The color of the nodes (default: :black).\nnode_size: The size of the nodes (default: automatic).\nnode_marker: The marker style for the nodes (default: automatic).\nnode_strokewidth: The stroke width of the nodes (default: automatic).\nshow_node_labels: Whether to show labels on the nodes (default: false).\nshow_edge_labels: Whether to show labels on the edges (default: false).\nedge_color: The color of the edges (default: :black).\nelabels_color: The color of the edge labels (default: :black).\nelabels_fontsize: The font size of the edge labels (default: 10).\ntangents: The tangents for the edges (default: ((0,-1),(0,-1))).\narrow_show: Whether to show arrows on the edges (default: false).\narrow_marker: The marker style for the arrows (default: '➤').\narrow_size: The size of the arrows (default: 50).\narrow_shift: The shift of the arrows along the edges (default: 0.5).\n\nReturns\n\nA plot object representing the network graph.\n\nExample\n\nf, ax, p = network_graph_plot(network_graph; layout=GraphMakie.Buchheim(), figure_size=(1000, 1200), node_color=:black, node_size=automatic, node_marker=automatic, node_strokewidth=automatic, show_node_labels=false, show_edge_labels=false, edge_color=:black, elabels_color=:black, elabels_fontsize=10, tangents=((0,-1),(0,-1)), arrow_show=false, arrow_marker='➤', arrow_size=50, arrow_shift=0.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.plot_network_coords-Tuple{Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDGraph.plot_network_coords","text":"plot_network_coords(eng::Dict{String,Any}; show_node_labels=false, show_edge_labels=false, fallback_layout=GraphMakie.Buchheim(), kwargs...)\n\nPlot a network graph with optional node and edge labels.\n\nArguments\n\neng::Dict{String,Any}: The engineering data used to create the network graph.\nshow_node_labels::Bool: Whether to display labels for the nodes. Default is false.\nshow_edge_labels::Bool: Whether to display labels for the edges. Default is false.\nfallback_layout: The layout algorithm to use if no specific layout is provided. Default is GraphMakie.Buchheim().\nnetwork_graph::MetaDiGraph: The network graph to be plotted.\nGraphLayout::Function: The layout function for positioning the nodes.\ntiles_provider: The tile provider for the map background. Default is TileProviders.Google(:satelite).\nzoom_lon: The longitudinal zoom level. Default is 0.0942.\nzoom_lat: The latitudinal zoom level. Default is 0.0942.\nmakie_backend: The Makie backend to use for plotting. Default is WGLMakie.\nfigure_size: The size of the figure in pixels. Default is (1000, 1200).\nnlabels: Node labels. Default is nothing.\nilabels: Internal labels. Default is nothing.\nnode_color: Color of the nodes. Default is :black.\nnode_size: Size of the nodes. Default is automatic.\nnode_marker: Marker style for the nodes. Default is automatic.\nnode_strokewidth: Stroke width of the nodes. Default is automatic.\nshow_node_labels: Whether to show node labels. Default is false.\nelabels: Edge labels. Default is nothing.\nshow_edge_labels: Whether to show edge labels. Default is false.\nedge_color: Color of the edges. Default is :black.\nelabels_color: Color of the edge labels. Default is :black.\nelabels_fontsize: Font size of the edge labels. Default is 10.\ntangents: Tangents for the edges. Default is ((0,-1),(0,-1)).\narrow_show: Whether to show arrows on the edges. Default is false.\narrow_marker: Marker style for the arrows. Default is '➤'.\narrow_size: Size of the arrows. Default is 12.\narrow_shift: Shift of the arrows. Default is 0.5.\nkwargs...: Additional keyword arguments to pass to the plotting function.\n\nReturns\n\nA plot of the network graph with the specified layout and labels.\n\nExample\n\nplot_network_coords(eng)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.plot_network_tree-Tuple{Dict{String, Any}}","page":"API Reference","title":"Pliers.PMDGraph.plot_network_tree","text":"plot_network_tree(eng::Dict{String,Any}; makie_backend=WGLMakie)\n\nPlots a network tree based on the given engineering model dictionary eng.\n\nArguments\n\neng::Dict{String,Any}: A dictionary containing the engineering model data.\nmakie_backend: The backend to use for plotting. Defaults to WGLMakie.\nnetwork_graph::MetaDiGraph: The network graph to be plotted.\nGraphLayout::Function: The layout function for positioning the nodes.\ntiles_provider: The tile provider for the map background. Default is TileProviders.Google(:satelite).\nzoom_lon: The longitudinal zoom level. Default is 0.0942.\nzoom_lat: The latitudinal zoom level. Default is 0.0942.\nmakie_backend: The Makie backend to use for plotting. Default is WGLMakie.\nfigure_size: The size of the figure in pixels. Default is (1000, 1200).\nnlabels: Node labels. Default is nothing.\nilabels: Internal labels. Default is nothing.\nnode_color: Color of the nodes. Default is :black.\nnode_size: Size of the nodes. Default is automatic.\nnode_marker: Marker style for the nodes. Default is automatic.\nnode_strokewidth: Stroke width of the nodes. Default is automatic.\nshow_node_labels: Whether to show node labels. Default is false.\nelabels: Edge labels. Default is nothing.\nshow_edge_labels: Whether to show edge labels. Default is false.\nedge_color: Color of the edges. Default is :black.\nelabels_color: Color of the edge labels. Default is :black.\nelabels_fontsize: Font size of the edge labels. Default is 10.\ntangents: Tangents for the edges. Default is ((0,-1),(0,-1)).\narrow_show: Whether to show arrows on the edges. Default is false.\narrow_marker: Marker style for the arrows. Default is '➤'.\narrow_size: Size of the arrows. Default is 12.\narrow_shift: Shift of the arrows. Default is 0.5.\nkwargs: Additional keyword arguments.\n\nReturns\n\nA tuple (f, ax, p) where f is the figure, ax is the axis, and p is the plot object.\n\nDetails\n\nActivates the specified Makie backend.\nConverts the keys of the engineering model dictionary to symbols.\nCreates a MetaDiGraph to represent the network graph.\nAdds bus keys as :bus_id and line keys as :line_id.\nAdds the sourcebus as the root vertex of the network graph.\nAdds the rest of the buses to the network graph.\nSets the indexing property of the network graph to :bus_id.\nAdds edges to the network graph based on the f_bus and t_bus indices.\nPlots the network graph using graphplot with labels for nodes and edges.\nHides decorations and spines of the plot axis.\n\nErrors\n\nThrows an error if sourcebus is not found in the bus data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.plot_network_tree-Tuple{String}","page":"API Reference","title":"Pliers.PMDGraph.plot_network_tree","text":"plot_network_tree(dss::String; kwargs...)\n\nPlots a network tree from a given DSS file.\n\nArguments\n\ndss::String: The path to the DSS file containing the network data.\nmakie_backend: The Makie backend to use for plotting. Defaults to WGLMakie.\n\nDescription\n\nThis function parses the DSS file to create an engineering model of the network, transforms loops in the model, and converts keys to symbols. It then constructs a network graph using MetaDiGraph, adds vertices for each bus, and sets the sourcebus as the root. Edges are added based on the f_bus and t_bus indices of the lines. Finally, it plots the network graph using graphplot with a specified layout and labels for nodes and edges.\n\nReturns\n\nA plot of the network graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pliers.PMDGraph.set_indexing_prop!-Tuple{MetaGraphs.AbstractMetaGraph, Symbol}","page":"API Reference","title":"Pliers.PMDGraph.set_indexing_prop!","text":"set_indexing_prop!(g, prop)\nset_indexing_prop!(g, v, prop, val)\n\nMake property prop into an indexing property. If any values for this property are already set, each vertex must have unique values. Optionally, set the index val for vertex v. Any vertices without values will be set to a default (\"(prop)(v)\").\n\n\n\n\n\n","category":"method"},{"location":"TODO/#General-Todos:","page":"To-Do List","title":"General Todos:","text":"[x] Create a README.md, as initial documentation.\n[ ] Main PMD features\n[x] explore ENGINEERING model summary\n[x] explore ENGINEERING model details \n[x] filter elements ENGINEERING model details with a specific rule\n[x] plot a tree of a DSS file \n[x] plot a tree of a PMD ENGINEERING Model \n[x] plot a real graph if file has coordinates\n[ ] explore MATHEMATICAL model summary\n[x] explore MATHEMATICAL model details\n[x] filter elements MATHEMATICAL model details with a specific rule\n[ ] missing elements in MATHEMATICAL model [transformer, switch and shunt]\n[x] plot a tree of a PMD MATHEMATICAL Model\n[x] plot a real graph if file has coordinates\n[ ] explore SIMULATION RESULTS model summary\n[ ] INVESTIGATE WHY THE LOAD CURRENTS DO NOT MATCH OPENDSS ALTHOUGH VOLTAGES DO – SEEMS TO BE A BUG\n[ ] explore SIMULATION RESULTS model details\n[ ] filter elements SIMULATION RESULTS model details with a specific rule\n[x] plot a tree of a PMD SIMULATION RESULTS Model with results on top of the graph\n[ ] if Buchheim assumption fails, then try to split the tree ?!?????????\n[x] plot a real graph if file has coordinates with results on top of the graph\n[x] add all test feeders as JLD2","category":"section"},{"location":"TODO/#General-Features:","page":"To-Do List","title":"General Features:","text":"Functional Requirements:","category":"section"},{"location":"TODO/#Basic-ENG-Model-Features:","page":"To-Do List","title":"Basic ENG Model Features:","text":"I want to be able to give a PMD ENGINEERING model and get a summary of it and details of its components\nI want to be able to filter the components of a PMD ENGINEERING model with a specific rule\nI want to be able to plot a tree of a DSS file\nI want to be able to plot a tree of a PMD ENGINEERING Model\nI want to be able to plot a real graph if file has coordinates","category":"section"},{"location":"TODO/#Basic-MATH-Model-Features:","page":"To-Do List","title":"Basic MATH Model Features:","text":"I want to be able to give a PMD MATHEMATICAL model and get a summary of it and details of its components\nI want to be able to filter the components of a PMD MATHEMATICAL model with a specific rule\nI want to be able to plot a tree of a PMD MATHEMATICAL Model\nI want to be able to plot a real graph if file has coordinates","category":"section"},{"location":"TODO/#Basic-SIM-Model-Features:","page":"To-Do List","title":"Basic SIM Model Features:","text":"I want to be able to give a PMD SIMULATION RESULTS model and get a summary of it and details of its components\nI want to be able to filter the components of a PMD SIMULATION RESULTS model with a specific rule\nI want to be able to plot a tree of a PMD SIMULATION RESULTS Model with results on top of the graph\nI want to be able to plot a real graph if file has coordinates with results on top of the graph","category":"section"},{"location":"TODO/#Advanced-PMD-Features:","page":"To-Do List","title":"Advanced PMD Features:","text":"I want to be able to compare two models that I have loaded\nI want to be able edit a model that I have loaded – specific table item (bus, line, etc.) or add a new item\nI want to be able to convert a model from one format to another\n\nList the tiles Tyler.TileProviders.list_providers()","category":"section"},{"location":"#Pliers.jl-Documentation","page":"Home","title":"Pliers.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"Pliers.jl is a collection of tools that I usually need (like pliers for an electrician) for analyzing power distribution systems. It is designed to be used in conjunction with the PowerModelsDistribution.jl or PowerModelsDistributionStateEstimation.jl packages for simplified reporting, analysis and visualization.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Network Visualization: Plot distribution networks as trees, with coordinates, or on geographic maps\nModel Exploration: Generate reports and tables for engineering and mathematical network models\nState Estimation Tools: Visualize residuals and analyze measurement data\nResult Processing: Transform and analyze power flow results","category":"section"},{"location":"#Package-Organization","page":"Home","title":"Package Organization","text":"Pliers.jl provides all functionality through the main module. For organizational purposes, functions are also re-exported through sub-modules that group related functionality:","category":"section"},{"location":"#PMDUtils","page":"Home","title":"PMDUtils","text":"Re-exports utility functions for PowerModelsDistribution workflows including:\n\nSolution processing (voltage fluffing, dictification)\nImpedance calculations (Kron reduction, sequence components)\nNetwork data manipulation\nEngineering and mathematical model exploration","category":"section"},{"location":"#PMDSEUtils","page":"Home","title":"PMDSEUtils","text":"Re-exports utility functions for PowerModelsDistributionStateEstimation workflows including:\n\nState estimation result visualization\nMeasurement residual analysis\nMeasurement data processing and writing","category":"section"},{"location":"#PMDGraph","page":"Home","title":"PMDGraph","text":"Re-exports plotting functions for network visualization including:\n\nNetwork tree visualization\nCoordinate-based network plotting\nGeographic map overlays\nBus phasor diagram plotting","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Currently Pliers is still under development and not registered. You can install it by cloning the repository and adding it to your Julia environment:\n\nusing Pkg\nPkg.develop(url=\"https://github.com/MohamedNumair/Pliers.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Pliers\n\n# Set journal-quality theme for plots\ninch, pt, cm, ieeecolumn, ieee2column = set_journal_theme()\n\n# Generate a report for an engineering model\n# eng_report(eng)\n\n# Visualize network as a tree\n# plot_network_tree(network_graph)","category":"section"},{"location":"#Author","page":"Home","title":"Author","text":"This package was developed by Mohamed Numair (mnumair.com)","category":"section"}]
}
